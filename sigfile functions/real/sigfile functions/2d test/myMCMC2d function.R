source("/Users/yilinsmac/Desktop/sigfile functions/2d test/myMCMC2d function.r")
## function to perform MCMC based on previous functions: 
library(MASS)
#test in 2-d
myMCMC2d=function(psdata, n=300,H=200,d=2,t=50,tby=1,sf=0.01,erv1=1,erv2=0.0001){ 
#psdata is the real data to deal with; 
#erv1 is the noise variance, with scaling factor sf
#erv2 is the variance of proposal distribution for iteration<=100; 
# n is the number of iterations of MCMC.
# d is the dimension of the parameters to infer.
#H is the memory parameter, n>=H at least

##  now start implementing MCMC:
 # "real"data is generated by previous function
cd=2.4/sqrt(d)
a=matrix(nrow=n,ncol=d);
a0=runif(2) 
a[1,]=a0 # generates and stores 13 inital guesses

# log-likelihood l for datat using guess:
lold=myloglk2d(a1=a[1,],t=t,tby=tby,psdata=psdata,erv1=erv1,sf=sf)
er=mvrnorm(n-1-H,mu=rep(0,H),Sigma=diag(H))
# Using while-loop
for (MCitr in 1:(n-1)){
	if (MCitr <= H){
		a2=mvrnorm(1,mu=a[MCitr,],Sigma=erv2*diag(2))
	}
	else {
		# the change of notation is just to be consistent with the paper given by Sarah
   K=a[(MCitr-H+1):MCitr,] #dim(K)=H*d
   rmean=rowMeans(K, na.rm = FALSE, dims = 1) #row means of the matrix a
  Ktilda=K-rmean #Ktilda is the centered matrix
  Rt=(1/(H-1))*t(Ktilda)%*%Ktilda; #dim(Rt)=d*d
  
  # propose a new candidate for a:
 # a2=mvrnorm(1,mu=a[MCitr,],Sigma=(cd^2)*Rt)  #why cannot I just use this to generate guesses?  
 
  a2=a[MCitr,]+cd*sqrt(1/(H-1))*t(Ktilda)%*%(er[(MCitr-H),]) 
}
 
  
if (a2[1]<0 || a2[2]<0 || a2[1]>1|| a2[2]>1){
a[MCitr+1,]=a[MCitr,]
# print(paste("acurrent", a[MCtime],", aproposed rejected=", a2,"outside of the prior"))
} else {

	# to compute log-likelihood based on guess a2:
	lnew=myloglk2d(a1=a2,t=t,tby=tby,psdata=psdata,erv1=erv1,sf=sf)

 
## to compute M-H
  alpha=min(1,exp(lnew-lold))
   u=runif(1)
#   print(paste("MCtime=", MCtime,", lold=",lold, ", lnew=",lnew, "likratio=",exp(lnew-lold) ))
   if (u<=alpha){
	a[MCitr+1,]=a2
	lold=lnew
#	print(paste("acurrent", a[MCtime],", aproposed accepted=", a2,", alpha=", alpha,", u=",u ))
      } # end if
       else{
		a[MCitr+1,]=a[MCitr,]
#print(paste("acurrent", a[MCtime],", aproposed rejected=", a2,", alpha=", alpha,", u=",u ))
	 }# end else
	 } #end else
	
lnew=NA	 
} #end for 
return(a)}