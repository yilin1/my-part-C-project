## function to perform MCMC based on previous functions: 
library(MASS)

myMCMC13adap=function(psdata, n=30,H=10,d,t=50,tby=1,sf=0.01,erv1=1,erv2=0.0001){ 
#psdata is the real data to deal with; 
#erv1 is the noise variance, with scaling factor sf
#erv2 is the variance of proposal distribution for iteration<=100; 
# n is the number of iterations of MCMC.
# d is the dimension of the parameters to infer.
#H is the memory parameter, n>=H at least

##  now start implementing MCMC:
 # "real"data is generated by previous function
cd=2.4/sqrt(d)
a=matrix(nrow=n,ncol=d);
a0=runif(13) 
a[1,]=a0 # generates and stores 13 inital guesses

# log-likelihood l for datat using guess:
lold=myloglk13(a1=a[1,],t=t,tby=tby,psdata=psdata,erv1=erv1,sf=sf)
 
# Using while-loop
for (MCitr in 1:(n-1)){
	if (MCitr <= H){
		a2=mvrnorm(1,mu=a[MCitr,],Sigma=erv2*diag(13))
	}
	else {
		# the change of notation is just to be consistent with the paper given by Sarah
   K=a[MCitr-H+1:MCitr,] #dim(K)=H*d
   rmean=rowMeans(K, na.rm = FALSE, dims = 1) #row means of the matrix a
  Ktilda=K-rmean #Ktilda is the centered matrix
  Rt=(1/(H-1))*t(Ktilda)%*%Ktilda; #dim(Rt)=d*d
  
  # propose a new candidate for a:
 # a2=mvrnorm(1,mu=a[MCitr,],Sigma=(cd^2)*Rt)  #why cannot I just use this to generate guesses?  
 er=mvrnorm(2,mu=rep(0,H),Sigma=diag(H)) #not H right??
  a2=a[MCitr,]+cd*sqrt(1/(H-1))*t(Ktilda)%*%(er[1,]) # dont understnad 
}
 
  
if (a2[1]<0 || a2[2]<0 ||a2[3]<0 ||a2[4]<0 ||a2[5]<0 ||a2[6]<0 ||a2[7]<0 || a2[8]<0 || a2[9]<0 || a2[10]<0 || a2[11]<0 || a2[12]<0 || a2[13]<0 || a2[1]>1|| a2[2]>1 ||a2[3]>1 ||a2[4]>1 ||a2[5]>1 ||a2[6]>1||a2[7]>1 ||a2[8]>1 ||a2[9]>1 ||a2[10]>1 ||a2[11]>1 ||a2[12]>1|| a2[13]>1){
a[MCitr+1,]=a[MCitr,]
# print(paste("acurrent", a[MCtime],", aproposed rejected=", a2,"outside of the prior"))
} else {

	# to compute log-likelihood based on guess a2:
	lnew=myloglk13(a1=a2,t=t,tby=tby,psdata=psdata,erv1=erv1,sf=sf)

 
## to compute M-H
  alpha=min(1,exp(lnew-lold))
   u=runif(1)
#   print(paste("MCtime=", MCtime,", lold=",lold, ", lnew=",lnew, "likratio=",exp(lnew-lold) ))
   if (u<=alpha){
	a[MCitr+1,]=a2
	lold=lnew
#	print(paste("acurrent", a[MCtime],", aproposed accepted=", a2,", alpha=", alpha,", u=",u ))
      } # end if
       else{
		a[MCitr+1,]=a[MCitr,]
#print(paste("acurrent", a[MCtime],", aproposed rejected=", a2,", alpha=", alpha,", u=",u ))
	 }# end else
	 } #end else
	
lnew=NA	 
} #end for 
return(a)}